function [d] = PuzzleFit(ShreddedImg, V)
    section_size = 40;
    num_sections = length(V);
    d = 0;
    % Initialize a cell array to store the border pixels for each section
    section_borders = cell(num_sections, 1);
    % Loop through each section and get the border pixels
    for i = 1:num_sections
        % Calculate the row and column indices for this section
        row_idx = floor((i - 1) / (size(ShreddedImg, 2) / section_size)) * section_size + 1;
        col_idx = mod(i - 1, size(ShreddedImg, 2) / section_size) * section_size + 1;
        
        % Get the pixels for this section
        section_pixels = ShreddedImg(row_idx:row_idx + section_size - 1, col_idx:col_idx + section_size - 1, :);
        %figure, imshow(uint8(section_pixels)), title('Section');
        % Get the border pixels for this section
        top_border = section_pixels(1, :, :);
        bottom_border = section_pixels(40, :, :);
        left_border = section_pixels(:, 1, :);
        right_border = section_pixels(:, 40, :);

        % Store the border pixels in the cell array
        section_borders{i} = {top_border, bottom_border, left_border, right_border};
    end
    %V = randperm(88)-1;
    Vborders = cell(num_sections, 1);

    for b=1:num_sections
        Vborders(b) = section_borders(V(b)+1);
        %figure, imshow(uint8(Vborders{1, 1}{1, 1})), title("mixtest");
    end
    borders = reshape(Vborders, 11, 8);
    borders = borders';
    

    for x = 1:size(borders, 1)
        for j = 1:size(borders, 2)
            % get current section borders
            tempd = 0;
            totalPixels = 0;
            curr_borders = borders{x,j};
            testlat = zeros(40, 2, 3);
            testlong = zeros(2, 40, 3);
            % calculate L2-norm with border to the right
            if j < size(borders, 2)
                right_borders = borders{x,j+1};
                tempd = tempd + sum(sum((curr_borders{4} - right_borders{3}).^2));
                testlat = uint8(curr_borders{4});
                testlat(:, 2,:) = uint8(right_borders{3});
                figure, imshow(testlat), title('currleft');
                %figure, imshow(uint8(right_borders{3})), title('rightright');
                totalPixels = totalPixels + section_size;
            end
            
            % calculate L2-norm with border below
            if x < size(borders, 1)
                bottom_borders = borders{x+1,j};
                tempd = tempd + sum(sum((curr_borders{2} - bottom_borders{1}).^2));
                %testlong = uint8(curr_borders{2});
                %testlong(2, : ,:) = uint8(bottom_borders{1});
                %figure, imshow(testlong), title('currtop');
                %figure, imshow(uint8(curr_borders{2})), title('currleft');
                %figure, imshow(uint8(bottom_borders{1})), title('rightright');
                totalPixels = totalPixels + section_size;
            end

            if j > 1
                left_borders = borders{x,j-1};
                tempd = tempd + sum(sum((curr_borders{3} - left_borders{4}).^2));
                %testlat = uint8(curr_borders{3});
                %testlat(:, 2,:) = uint8(right_borders{4});
                %figure, imshow(testlat), title('currright');
                %figure, imshow(uint8(curr_borders{2})), title('currleft');
                %figure, imshow(uint8(bottom_borders{1})), title('rightright');
                totalPixels = totalPixels + section_size;
            end
            
            % calculate L2-norm with border below
            if x > 1
                top_borders = borders{x-1,j};
                tempd = tempd + sum(sum((curr_borders{1} - top_borders{2}).^2));
                %testlong = uint8(curr_borders{1});
                %testlong(2, : ,:) = uint8(top_borders{2});
                %figure, imshow(testlong), title('currbot');
                %figure, imshow(uint8(curr_borders{2})), title('currleft');
                %figure, imshow(uint8(bottom_borders{1})), title('rightright');
                totalPixels = totalPixels + section_size;
            end
            d = d + (tempd/totalPixels);
        end
    d = sqrt(d);
    end
end